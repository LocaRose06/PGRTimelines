<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Student Payment Timeline Visualiser</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        
        /* New Wrapper for Controls - Styles for the Summary */
        #mainControlsDetails summary {
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 2px solid #333;
            margin-bottom: 15px;
        }
        #mainControlsDetails summary h2 {
             margin: 0;
             display: inline-block;
             color: #007bff;
        }


        #controls {
            padding: 15px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        #controls h2 { /* Reset h2 margin inside the inner controls div */
            margin-top: 0;
        }
        .input-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 160px;
            font-weight: bold;
        }
        input[type="date"], input[type="text"], input[type="number"] { 
            padding: 5px;
            border: 1px solid #aaa;
        }
        #fundingDescription {
             width: 50%;
        }
        
        /* New Manual Payments Section */
        #manualPaymentDetails {
            border: 1px dashed #007bff;
            padding: 10px;
            margin-top: 10px;
            background-color: #f0f8ff;
        }
        #manualPaymentDetails summary {
            font-weight: bold;
            color: #007bff;
            cursor: pointer;
        }
        .manual-payment-entry {
            border-bottom: 1px dashed #b3d9ff;
            padding: 8px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .manual-payment-entry:last-child {
            border-bottom: none;
        }
        .manual-payment-entry input[type="date"] {
            width: 140px;
        }


        /* New LOA Guide Styles (Applied to the <details> element) */
        #loaGuide {
            border: 2px solid #007bff;
            padding: 0 15px 15px 15px; 
            margin-top: 20px;
            background-color: #e6f7ff;
            border-radius: 5px;
        }

        /* Style for the summary section (the clickable title) */
        #loaGuide summary {
            cursor: pointer;
            padding: 15px 0; 
        }
        
        /* Style for the h3 inside the summary */
        #loaGuide summary h3 {
            color: #007bff;
            border-bottom: 1px solid #007bff;
            padding-bottom: 5px;
            margin: 0; 
            display: inline-block; 
        }

        /* Table styles remain the same for the content inside */
        #loaGuide table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        #loaGuide th, #loaGuide td {
            border: 1px solid #b3d9ff;
            padding: 8px;
            text-align: left;
        }
        #loaGuide th {
            background-color: #cceeff;
            font-weight: bold;
        }
        
        /* Leave List Styles */
        #leavePeriods {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 15px;
            background-color: #fff;
        }
        .leave-entry {
            border-bottom: 1px dashed #eee;
            padding: 8px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .leave-entry input[type="date"] {
            width: 140px;
        }
        .leave-entry input[type="text"] {
            flex-grow: 1;
            min-width: 150px;
        }
        .leave-entry:last-child {
            border-bottom: none;
        }
        .remove-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .action-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        /* PDF Download Button Style */
        #downloadPdfBtn {
            background-color: #28a745;
            margin-left: 10px;
        }
        
        .type-select {
            padding: 5px;
        }


        /* Visualization Container */
        #timeline-container {
            border: 1px solid #333;
            min-height: 100px;
            padding: 10px;
            background-color: #fff;
        }
        
        /* Shared Style for all markers */
        .timeline-marker {
            color: white;
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
            width: 380px; 
            text-align: left;
            display: block; 
            transition: background-color 0.2s;
        }
        .timeline-marker h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        .timeline-marker ul {
            list-style: disc;
            margin: 5px 0 0 20px;
            padding: 0;
            font-size: 0.9em;
        }
        .timeline-marker ul strong {
             color: inherit;
        }


        /* Green Block (Regular Payment) */
        .payment-marker {
            background-color: #4CAF50;
        }

        /* LIGHT BLUE Block (Split/Combined Payment/Catch Up) */
        .payment-marker-split {
            background-color: #00bcd4;
            color: #333;
        }
        
        /* Medical Funded (Teal) or Capped Funded - NOW USED FOR COMBINED BLOCK IF FULL LOA */
        .leave-marker-medical, .leave-marker-funded-capped {
            background-color: #17a2b8;
            border: 2px solid #0f6674;
        }
        /* Maternity Funded (Pink) - NOW USED FOR COMBINED BLOCK IF FULL LOA */
        .leave-marker-maternity-full {
             background-color: #ff69b4;
             border: 2px solid #c9006b;
        }
        /* Maternity SMP (Lighter Pink) - NOW USED FOR COMBINED BLOCK IF FULL LOA */
        .leave-marker-maternity-smp {
             background-color: #ffb7d5;
             color: #333;
             border: 2px solid #d45c84;
        }
        /* NEW: Maternity Mixed/Split Payment (Peach/Salmon) */
        .leave-marker-maternity-split {
             background-color: #ff8c94;
             color: #333;
             border: 2px solid #d85c65;
        }


        /* Grey Block (Unfunded LOA - The only one rendered separately now) */
        .leave-marker-unfunded {
            background-color: #6c757d;
            border: 2px dashed #495057;
        }

        .payment-marker-prorata {
            background-color: #6d8e6e;
            border: 2px dashed #4CAF50;
        }
        
        /* New Style for Past Payments */
        .payment-marker-paid {
            background-color: #b0b0b0; /* Light grey for paid markers */
            color: #333;
            border: 2px dashed #666;
        }
        
        /* New Style for Grace/Offset Period */
        .grace-period-marker {
            background-color: #f0ad4e; /* Orange for warning/offset */
            color: #333;
            border: 2px solid #e08c1a;
        }

        /* NEW Style for Missed Period */
        .missed-period-marker {
            background-color: #ff4d4f; /* Red/Error color */
            color: white;
            border: 2px solid #a8071a;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.min.js"></script> 
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
</head>
<body>

    <h1>Student Stipend Timeline Visualiser</h1>

    <details id="mainControlsDetails" open>
        <summary><h2>Student Stipend Inputs and LOA Configuration (Click to Collapse)</h2></summary>
        <div id="controls">
            <h2>Input Details</h2>
            <div class="input-group">
                <label for="fundingDescription">Name:</label>
                <input type="text" id="fundingDescription" value="">
            </div>
            <div class="input-group">
                <label for="startDate">Student Start Date:</label>
                <input type="date" id="startDate" value="">
            </div>
            <div class="input-group">
                <label for="fundingEndDate">Funding End Date:</label>
                <input type="date" id="fundingEndDate" value="">
            </div>

            <hr>
            
            <h2>Past Payment History</h2>
            <div class="input-group">
                <label>Past Payments Mode:</label>
                <input type="radio" name="paymentMode" id="modeAuto" value="auto"> <label for="modeAuto" style="width: auto; font-weight: normal;">Automatic (Count)</label>
                <input type="radio" name="paymentMode" id="modeManual" value="manual" checked> <label for="modeManual" style="width: auto; font-weight: normal;">Manual Entry</label>
            </div>
            
            <div id="autoControls" class="input-group" style="display: none;">
                <label for="paymentsAlreadyMade">Payments Count (Regular 3-mo periods):</label>
                <input type="number" id="paymentsAlreadyMade" value="0" min="0" style="width: 50px;">
            </div>
            
            <details id="manualPaymentDetails" style="display: block;">
                <summary>Manual Payment Periods Already Made (Start & End Dates)</summary>
                <div id="manualPaymentsList">
                    </div>
                <button id="addManualPaymentBtn" class="action-btn" style="margin-top: 5px;">+ Add Paid Period</button>
                <p style="font-size: 0.8em; color: #555; margin-top: 10px;">*Enter the exact period (start and end date) that each payment actually covered. They will be processed chronologically. Use this mode to simulate non-standard or late-ending payments.</p>
            </details>

            <hr>
    
            <h2>Leave of Absence (LOA) Periods</h2>
            <div id="leavePeriods">
     
                <div class="leave-entry">
                    <select class="type-select">
                        <option value="unfunded" selected>Unfunded</option>
                        <option value="funded-uncapped">Funded (Uncapped)</option>
                        <option value="funded-capped">Funded (Capped)</option>
                        <option value="medical">Medical</option>
                        <option value="maternity">Maternity</option>
                    </select>
                    Start: <input type="date" class="leave-start" value="">
                    End: <input type="date" class="leave-end" value="">
                    Description: <input type="text" class="leave-description" placeholder="e.g., Parental Leave" value="">
                    <button class="remove-btn" onclick="this.parentNode.remove()">Remove</button>
                </div>
                
            </div>
            
            <button id="addLeaveBtn" class="action-btn">+ Add Another Leave Period</button>
            
            <br><br>
            <button id="generateTimelineBtn" class="action-btn">Generate Timeline</button>
            <button id="downloadPdfBtn" class="action-btn">Download PDF ‚¨áÔ∏è</button>
            
            <details id="loaGuide"> 
                <summary>
                    <h3>LOA Selection Guide üìö (Click to Expand)</h3>
                </summary>
                
                <p>Use the <strong>Type</strong> dropdown for the LOA period based on the statutory leave reason:</p>
                <table>
                    <thead>
                   
                         <tr>
                            <th>Leave Type (Reason)</th>
                            <th>Recommended Input Type</th>
                            <th>Allowance / Policy Details</th>
                    
                         </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Medical LOA</strong></td>
                       
                         <td><strong>Medical</strong></td>
                            <td><strong>28 weeks</strong> (196 days) of funding per <strong>12-month rolling period</strong>.</td>
                        </tr>
                        <tr>
                          
                         <td><strong>Maternity/Adoption/Death during Maternity</strong></td>
                            <td><strong>Maternity</strong></td>
                            <td><strong>26 weeks</strong> Full Stipend, followed by <strong>13 weeks</strong> Statutory Maternity Pay (<strong>SMP</strong>).</td>
                        </tr>
                     
                         <tr>
                            <td><strong>Baby Loss (after 24 weeks or in first 52 weeks of birth)</strong></td>
                            <td><strong>Maternity</strong></td>
                            <td>Treated the same as Maternity Leave (26 weeks full, 13 weeks SMP).</td>
       
                      </tr>
                        <tr>
                            <td><strong>Paternity Leave</strong></td>
                            <td><strong>Funded (Uncapped)</strong></td>
                 
                            <td><strong>2 weeks</strong> (14 days) of fully funded leave.
                            <strong>Uncapped</strong> against the Global 52-week limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Neonatal Care Leave</strong></td>
                            <td><strong>Funded (Uncapped)</strong></td>
        
                            <td><strong>13 weeks</strong> (91 days) of fully funded leave.
                            <strong>Uncapped</strong> against the Global 52-week limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Special Leave</strong> (Bereavement, Pregnancy Loss, Emergencies)</td>
                            <td><strong>Funded (Capped)</strong></td>
     
                            <td><strong>2 weeks</strong> (14 days) fully funded.
                            <strong>Capped</strong> against the Global 52-week program limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Carer</strong></td>
                            <td><strong>Funded (Capped)</strong></td>
         
                            <td><strong>1 week</strong> (7 days) fully funded.
                            <strong>Capped</strong> against the Global 52-week program limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Disability</strong></td>
                            <td><strong>Funded (Capped)</strong></td>
         
                            <td><strong>4 weeks</strong> (28 days) fully funded.
                            <strong>Capped</strong> against the Global 52-week program limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Health & Safety</strong></td>
                            <td><strong>Funded (Capped)</strong></td>
       
                            <td><strong>4 weeks</strong> (28 days) fully funded.
                            <strong>Capped</strong> against the Global 52-week program limit.</td>
                        </tr>
                        <tr>
                            <td><strong>Public Duties</strong></td>
                            <td><strong>Funded (Capped)</strong></td>
        
                            <td><strong>Variable</strong> duration fully funded.
                            <strong>Capped</strong> against the Global 52-week program limit.</td>
                        </tr>
                    </tbody>
                </table>
                <p><em>Unfunded LOA: Use the <strong>Unfunded</strong> type for any period of leave that is statutory but not funded (e.g., parental leave after funded entitlements are exhausted).</em></p>
            </details>
      
        </div>
    </details>

    ---

    <h2>Timeline Results</h2>
    <p id="correction-note" style="color: darkred; font-weight: bold;"></p>
    <div id="timeline-results-section"> 
        <div id="timeline-container">
            Press "Generate Timeline" to see the payment schedule.
        </div>
    </div>


    <script>
        // --- CONSTANTS ---
        const MEDICAL_ROLLING_CAP_DAYS = 28 * 7;
        const GLOBAL_FUNDED_CAP_DAYS = 52 * 7 + 1; // 365 days
        const MATERNITY_FULL_PAY_DAYS = 26 * 7;
        const MATERNITY_SMP_DAYS = 13 * 7;
        const QUARTERLY_MONTHS = 3;
        // --- CORE HELPER FUNCTIONS ---

        function createDate(dateString) {
            if (!dateString) return null;
            const parts = dateString.split('-');
            // Use Date.UTC to prevent timezone issues shifting the date
            return new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
        }

        function dateDiffInDays(date1, date2) {
            if (!date1 || !date2 || date1 > date2) return 0;
            const _MS_PER_DAY = 1000 * 60 * 60 * 24;
            const utc1 = Date.UTC(date1.getUTCFullYear(), date1.getUTCMonth(), date1.getUTCDate());
            const utc2 = Date.UTC(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate());
            // Use ceil and add 1 day to ensure inclusive day count: (end - start) + 1
            return Math.ceil((utc2 - utc1) / _MS_PER_DAY) + 1;
        }

        function formatDate(date) {
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            return `${day}-${month}-${year}`;
        }
        
        /**
         * Adjusts a date to the next valid payment date (1st or 15th).
         */
        function adjustToPayDate(date) {
            const day = date.getUTCDate();
            let adjustedDate = new Date(date); 

            if (day === 1 || day === 15) {
                return adjustedDate;
            } else if (day < 15) {
                // If it's the 1st to the 14th, adjust to the 15th
                adjustedDate.setUTCDate(15);
            } else {
                // If it's the 16th to the end of the month, adjust to the 1st of the next month
                adjustedDate.setUTCMonth(adjustedDate.getUTCMonth() + 1);
                adjustedDate.setUTCDate(1);
            }
            return adjustedDate;
        }

        /**
         * Finds ALL LOAs that overlap with the given payment *period*.
         */
        function getLeavesInEffect(periodStart, periodEnd, leaveEntries) {
            const overlappingLeaves = [];
            for (const leave of leaveEntries) {
                // Check for overlap: The leave must start before the period ends AND end after the period starts.
                if (leave.start <= periodEnd && leave.end >= periodStart) {
                    overlappingLeaves.push(leave);
                }
                // Optimization: If the leave starts after the period ends, we can stop searching.
                if (leave.start > periodEnd && overlappingLeaves.length === 0) {
                    // return []; // Disabled optimization due to complex sorting edge cases
                }
            }
            // Sort by start date to process chronologically
            overlappingLeaves.sort((a, b) => a.start - b.start);
            return overlappingLeaves;
        }


        function getLeaveDurationInfo(start, end) {
            const totalDays = dateDiffInDays(start, end);
            let durationInfo = {};
            
            const weeks = Math.floor(totalDays / 7);
            const days = totalDays % 7;
            
            let parts = [];
            if (weeks > 0) parts.push(`${weeks} week${weeks > 1 ? 's' : ''}`);
            if (days > 0) parts.push(`${days} day${days > 1 ? 's' : ''}`);
            
            const display = parts.length > 0 ?
            parts.join(', ') : `${totalDays} days`;
            durationInfo.display = `${display} (${totalDays} days)`;

            return { totalDays, display: durationInfo.display };
        }
        
        function addLeavePeriod() {
            const container = document.getElementById('leavePeriods');
            const newEntry = document.createElement('div');
            newEntry.className = 'leave-entry';
            newEntry.innerHTML = `
                <select class="type-select">
                    <option value="unfunded" selected>Unfunded</option>
                    <option value="funded-uncapped">Funded (Uncapped)</option>
                    <option value="funded-capped">Funded (Capped)</option>
        
                    <option value="medical">Medical</option>
                    <option value="maternity">Maternity</option>
                </select>
                Start: <input type="date" class="leave-start">
                End: <input type="date" class="leave-end">
            
                Description: <input type="text" class="leave-description" placeholder="e.g., Parental Leave">
                <button class="remove-btn" onclick="this.parentNode.remove()">Remove</button>
            `;
            container.appendChild(newEntry);
        }
        
        /**
         * Adds a manual payment entry row to the UI.
         */
        function addManualPayment() {
            const container = document.getElementById('manualPaymentsList');
            const newEntry = document.createElement('div');
            newEntry.className = 'manual-payment-entry';
            newEntry.innerHTML = `
                Start: <input type="date" class="payment-start">
                End: <input type="date" class="payment-end">
                <button class="remove-btn" onclick="this.parentNode.remove()">Remove</button>
            `;
            container.appendChild(newEntry);
        }

        /**
         * Step 0: Processes Maternity Leave, splitting it into its three statutory stages.
         */
        function processMaternityLeave(rawLeaves) {
            let processedMaternity = [];
            for (const leave of rawLeaves) {
                if (leave.type !== 'maternity') {
                    processedMaternity.push(leave);
                    continue;
                }
                
                let currentStart = leave.start;
                let remainingDays = leave.totalDays;
                
                // 1. Full Pay (26 weeks / 182 days)
                let fullPayDays = Math.min(remainingDays, MATERNITY_FULL_PAY_DAYS);
                if (fullPayDays > 0) {
                    let end = new Date(currentStart);
                    end.setUTCDate(end.getUTCDate() + fullPayDays - 1);
                    const durationInfo = getLeaveDurationInfo(currentStart, end);
                    processedMaternity.push({ 
                        ...leave, 
                        start: currentStart, 
                        end: end, 
                        totalDays: fullPayDays,
                        display: durationInfo.display,
                        fundingType: 'funded', 
                        type: 'maternity-full', 
                        notes: `Maternity Leave (Full Stipend). Total ${MATERNITY_FULL_PAY_DAYS} days cap.`
                    });
                    currentStart = new Date(end);
                    currentStart.setUTCDate(currentStart.getUTCDate() + 1);
                    remainingDays -= fullPayDays;
                }
                
                // 2. SMP Pay (13 weeks / 91 days)
                let smpPayDays = Math.min(remainingDays, MATERNITY_SMP_DAYS);
                if (smpPayDays > 0) {
                    let end = new Date(currentStart);
                    end.setUTCDate(end.getUTCDate() + smpPayDays - 1);
                    const durationInfo = getLeaveDurationInfo(currentStart, end);
                    processedMaternity.push({ 
                        ...leave, 
                        start: currentStart, 
                        end: end, 
                        totalDays: smpPayDays,
                        display: durationInfo.display,
                        fundingType: 'reduced', 
                        type: 'maternity-smp', 
                        notes: `Maternity Leave (Statutory Maternity Pay - SMP). Total ${MATERNITY_SMP_DAYS} days cap.`
                    });
                    currentStart = new Date(end);
                    currentStart.setUTCDate(currentStart.getUTCDate() + 1);
                    remainingDays -= smpPayDays;
                }

                // 3. Unfunded Portion
                if (remainingDays > 0) {
                    const unfundedEnd = leave.end;
                    const durationInfo = getLeaveDurationInfo(currentStart, unfundedEnd);
                    processedMaternity.push({ 
                        ...leave, 
                        start: currentStart, 
                        end: unfundedEnd,
                        totalDays: remainingDays,
                        display: durationInfo.display,
                        fundingType: 'unfunded', 
                        type: 'maternity-unfunded', 
                        notes: `Maternity Leave (Unfunded Portion). Funded caps exhausted.`
                    });
                }
            }

            processedMaternity.sort((a, b) => a.start - b.start);
            return processedMaternity;
        }


        /**
         * Step 1: Processes raw medical leave against the 12-month rolling 196-day cap.
         */
        function processMedicalLeave(leaves) {
            let semiProcessed = [];
            for (const leave of leaves) {
                if (leave.originalType === 'maternity') { 
                     semiProcessed.push(leave);
                    continue;
                }

                if (leave.type !== 'medical') {
                    // FIX: Set fundingType to 'funded' for funded-capped/uncapped types
                    let calculatedFundingType = leave.type; 
                    if (leave.type === 'funded-uncapped' || leave.type === 'funded-capped') {
                        calculatedFundingType = 'funded';
                    }
                    if (leave.type === 'unfunded') {
                        calculatedFundingType = 'unfunded';
                    }
                    
                    semiProcessed.push({ 
                        ...leave, 
                        fundingType: calculatedFundingType, 
                        notes: '' 
                    }); 
                    continue;
                }
                
                const CAP = MEDICAL_ROLLING_CAP_DAYS;
                const oneYearAgo = new Date(leave.start);
                oneYearAgo.setUTCFullYear(oneYearAgo.getUTCFullYear() - 1);
                
                let daysUsedInPrior12Months = 0;
                semiProcessed.forEach(prevLeave => {
                    // Only check *funded* medical leaves
                    if (prevLeave.type === 'medical' && prevLeave.fundingType === 'funded') {
                         const lookBackEnd = new Date(leave.start);
                        lookBackEnd.setUTCDate(lookBackEnd.getUTCDate() - 1);

                        const overlapStart = prevLeave.start > oneYearAgo ? prevLeave.start : oneYearAgo;
                        const overlapEnd = prevLeave.end < lookBackEnd ? prevLeave.end : lookBackEnd;
                        
                        const overlapDays = dateDiffInDays(overlapStart, overlapEnd);
                        if (overlapDays > 0) {
                             daysUsedInPrior12Months += overlapDays;
                        }
                    }
                });
                const remainingCap = CAP - daysUsedInPrior12Months;
                const totalDuration = leave.totalDays;
                if (remainingCap <= 0) {
                    semiProcessed.push({ 
                        ...leave, 
                        fundingType: 'unfunded', 
                        type: 'medical-unfunded',
                        notes: `Medical rolling cap exceeded (0 days remaining in 12-month period. ${daysUsedInPrior12Months} days used in the prior 12 months)` 
                    });
                } else if (totalDuration <= remainingCap) {
                    semiProcessed.push({ 
                        ...leave, 
                        fundingType: 'funded', 
                        type: 'medical',
                        notes: `Medical leave fully funded. Rolling cap status: Using ${totalDuration} days. ${remainingCap - totalDuration} days remaining.`
                    });
                } else {
                    const fundedDays = remainingCap;
                    let fundedEnd = new Date(leave.start);
                    fundedEnd.setUTCDate(fundedEnd.getUTCDate() + fundedDays - 1);
                    // 1. Funded Portion
                    const fundedInfo = getLeaveDurationInfo(leave.start, fundedEnd);
                    semiProcessed.push({ 
                        ...leave, 
                        end: fundedEnd, 
                        totalDays: fundedDays,
                        display: fundedInfo.display,
                        fundingType: 'funded', 
                        type: 'medical',
                        notes: `Funded portion (Reached 12-month medical cap). Rolling cap status: Using ${fundedDays} days. 0 days remaining.` 
                    });
                    // 2. Unfunded Portion
                    const unfundedStart = new Date(fundedEnd);
                    unfundedStart.setUTCDate(unfundedStart.getUTCDate() + 1);
                    const unfundedDays = totalDuration - fundedDays;
                    const unfundedInfo = getLeaveDurationInfo(unfundedStart, leave.end);
                    semiProcessed.push({ 
                        ...leave, 
                        start: unfundedStart, 
                        end: leave.end,
                        totalDays: unfundedDays,
                        display: unfundedInfo.display,
                        fundingType: 'unfunded', 
                        type: 'medical-unfunded',
                        notes: `Unfunded portion (Rolling medical cap exceeded by ${unfundedDays} days).` 
                    });
                }
            }

            semiProcessed.sort((a, b) => a.start - b.start);
            return semiProcessed;
        }

        /**
         * Step 2: Processes the resulting funded leave against the Global 52-week program cap.
         */
        let cumulativeGlobalCappedDays = 0;
        // Global tracker for this cap across all calls
        function processGlobalCappedLeave(semiProcessedLeaves) {
            let processed = [];
            const CAP = GLOBAL_FUNDED_CAP_DAYS;
            
            for (const leave of semiProcessedLeaves) {
                if (leave.originalType === 'maternity') { 
                    processed.push(leave);
                    continue;
                }

                const isGloballyCappedFunded = (leave.fundingType === 'funded' && (leave.type === 'medical' || leave.type === 'funded-capped'));
                if (!isGloballyCappedFunded) {
                    processed.push(leave);
                    continue;
                }
                
                const remainingCap = CAP - cumulativeGlobalCappedDays;
                const totalDuration = leave.totalDays;

                if (remainingCap <= 0) {
                    const newType = leave.originalType === 'medical' ?
                    'medical-unfunded' : 'funded-capped-unfunded';
                    processed.push({ 
                        ...leave, 
                        fundingType: 'unfunded', 
                        type: newType,
                        notes: `Global 52-week cap exceeded (0 days remaining in program cap).`
                    });
                } else if (totalDuration <= remainingCap) {
                    cumulativeGlobalCappedDays += totalDuration;
                    let baseNote = leave.notes;
                    if (leave.type === 'funded-capped') {
                        baseNote = 'Funded capped leave is fully funded.';
                    } 
                    
                    processed.push({ 
                        ...leave, 
                        notes: `${baseNote.replace(/\.$/, '')}. Global Cap Status: Using ${totalDuration} days. ${CAP - cumulativeGlobalCappedDays} days remaining in program cap.`
                    });
                } else {
                    const fundedDays = remainingCap;
                    let fundedEnd = new Date(leave.start);
                    fundedEnd.setUTCDate(fundedEnd.getUTCDate() + fundedDays - 1);
                    // 1. Funded Portion (Global Cap Used)
                    processed.push({ 
                        ...leave, 
                        end: fundedEnd, 
                        totalDays: fundedDays,
                        display: getLeaveDurationInfo(leave.start, fundedEnd).display,
                        notes: `Funded portion (Reached global 52-week cap). Global Cap Status: Used ${fundedDays} days. 0 days remaining in program cap.` 
                    });
                    // 2. Unfunded Portion (Excess due to Global Cap)
                    const unfundedStart = new Date(fundedEnd);
                    unfundedStart.setUTCDate(unfundedStart.getUTCDate() + 1);
                    const unfundedDays = totalDuration - fundedDays;
                    const unfundedType = leave.originalType === 'medical' ? 'medical-unfunded' : 'funded-capped-unfunded';

                    processed.push({ 
                        ...leave, 
                        start: unfundedStart, 
                        end: leave.end,
                        totalDays: unfundedDays,
                        display: getLeaveDurationInfo(unfundedStart, leave.end).display,
                        fundingType: 'unfunded', 
                        type: unfundedType,
                        notes: `Unfunded portion (Global cap exceeded by ${unfundedDays} days).` 
                    });
                    cumulativeGlobalCappedDays += fundedDays;
                }
            }

            processed.sort((a, b) => a.start - b.start);
            return processed;
        }

        /**
         * Calculates the *shifted* payment schedule from a starting anchor date. 
         * This function handles LOA interruptions and is called for all planned future payments.
         */
        function calculateShiftedPayments(startAnchorDate, effectiveEndDate, processedLeaveEntries, startingCount) {
             let shiftedPayments = [];
             let paymentCount = startingCount;
             let lastAnchorDate = new Date(startAnchorDate);
             
             while (lastAnchorDate.getTime() <= effectiveEndDate.getTime()) {
                 let currentPeriodStart = new Date(lastAnchorDate);
                 let periodTargetEndDate = new Date(currentPeriodStart);
                 periodTargetEndDate.setUTCMonth(periodTargetEndDate.getUTCMonth() + QUARTERLY_MONTHS);
                 periodTargetEndDate.setUTCDate(periodTargetEndDate.getUTCDate() - 1);
                 
                 let finalPeriodEnd = new Date(periodTargetEndDate);
                 if (finalPeriodEnd.getTime() > effectiveEndDate.getTime()) {
                     finalPeriodEnd = new Date(effectiveEndDate);
                 }
                 
                 if (currentPeriodStart.getTime() > effectiveEndDate.getTime()) break;
 
                 let overlappingLeaves = getLeavesInEffect(currentPeriodStart, finalPeriodEnd, processedLeaveEntries);
                 // We only split a payment block if the LOA is unfunded. Funded/Reduced LOA is included in the payment block.
                 let firstUnfundedInterruption = overlappingLeaves.find(l => l.fundingType === 'unfunded' && l.start >= currentPeriodStart && l.start <= finalPeriodEnd);
 
                 let payment = {
                     count: paymentCount,
                     start: currentPeriodStart,
                     end: finalPeriodEnd,
                     type: 'REGULAR',
                     overlappingLeaves: overlappingLeaves // Store for combined payment rendering
                 };
                 
                 if (firstUnfundedInterruption) {
                     const preLoaEnd = new Date(firstUnfundedInterruption.start);
                     preLoaEnd.setUTCDate(preLoaEnd.getUTCDate() - 1);
 
                     if (preLoaEnd.getTime() >= currentPeriodStart.getTime()) {
                         let prePayment = {
                             count: paymentCount,
                             start: currentPeriodStart,
                             end: preLoaEnd,
                             type: 'PRO-RATA',
                             // Filter overlapping leaves to only those in the pre-LOA period
                             overlappingLeaves: overlappingLeaves.filter(l => l.start <= preLoaEnd)
                         };
                         shiftedPayments.push(prePayment);
                         paymentCount++;
                     }
                     
                     let newAnchor = new Date(firstUnfundedInterruption.end);
                     newAnchor.setUTCDate(newAnchor.getUTCDate() + 1);
                     lastAnchorDate = newAnchor;
                     
                     continue; 
                     
                 }
 
                 shiftedPayments.push(payment);
                 
                 lastAnchorDate = new Date(periodTargetEndDate);
                 lastAnchorDate.setUTCDate(lastAnchorDate.getUTCDate() + 1);
                 paymentCount++;
 
                 if (paymentCount > 100) break;
             }
 
             return shiftedPayments;
        }


        // --- MAIN GENERATOR FUNCTION ---
        function generateTimeline() {
            // --- 1. INITIAL SETUP & LEAVE PROCESSING ---
            const fundingDescription = document.getElementById('fundingDescription').value;
            const startDateInput = document.getElementById('startDate').value;
            const fundingEndDateInput = document.getElementById('fundingEndDate').value; 
            const timelineContainer = document.getElementById('timeline-container');
            const correctionNote = document.getElementById('correction-note');

            // Set initial content to show activity (will be overwritten later)
            timelineContainer.innerHTML = 'Generating timeline...';
            correctionNote.innerHTML = '';

            if (!startDateInput || !fundingEndDateInput) {
                timelineContainer.innerHTML = 'Please enter both start and funding end dates.';
                return;
            }

            const startDate = createDate(startDateInput);
            const initialFundingEndDate = createDate(fundingEndDateInput); 
            
            // --- Collect and Process LOA Data ---
            let rawLeaveEntries = []; 
            const leaveElements = document.querySelectorAll('#leavePeriods .leave-entry');
            leaveElements.forEach(el => {
                const type = el.querySelector('.type-select').value;
                const startString = el.querySelector('.leave-start').value;
                const endString = el.querySelector('.leave-end').value;
                const description = el.querySelector('.leave-description').value; 

                const start = createDate(startString);
                const end = createDate(endString);

                if (start && end && end >= start) {
                    const durationInfo = getLeaveDurationInfo(start, end);
                    rawLeaveEntries.push({ 
                        type, 
                        originalType: type, 
                        start, 
                        end, 
                        totalDays: durationInfo.totalDays, 
                        display: durationInfo.display,
                        notes: '', 
                        description: description || 'N/A' 
                    });
                }
            });
            
            rawLeaveEntries.sort((a, b) => a.start - b.start);
            
            // --- STAGE 0, 1 & 2: APPLY CAPS AND DETERMINE FUNDING STATUS ---
            const maternityProcessedLeaves = processMaternityLeave(rawLeaveEntries);
            const medicalProcessedLeaves = processMedicalLeave(maternityProcessedLeaves);
            cumulativeGlobalCappedDays = 0; // Reset global counter on each run
            const processedLeaveEntries = processGlobalCappedLeave(medicalProcessedLeaves);
            const initialTotalExtensionDays = processedLeaveEntries.filter(l => l.fundingType !== 'unfunded' && l.type !== 'maternity-smp').reduce((sum, leave) => sum + leave.totalDays, 0);


            // --- 2. Determine Paid History (Auto or Manual) ---
            let originalPayments = [];
            const modeManual = document.getElementById('modeManual').checked;
            let paymentsAlreadyMade;

            if (!modeManual) {
                // AUTO Mode: Use the count to generate regular quarterly payments
                paymentsAlreadyMade = parseInt(document.getElementById('paymentsAlreadyMade').value) || 0;
                let tempAnchor = new Date(startDate);
                let tempCount = 1;
                while (tempCount <= paymentsAlreadyMade) {
                    let tempStart = new Date(tempAnchor);
                    let tempEnd = new Date(tempStart);
                    tempEnd.setUTCMonth(tempEnd.getUTCMonth() + QUARTERLY_MONTHS);
                    tempEnd.setUTCDate(tempEnd.getUTCDate() - 1);
                    
                    originalPayments.push({ start: tempStart, end: tempEnd, count: tempCount, mode: 'Auto' });
                    
                    tempAnchor = new Date(tempEnd);
                    tempAnchor.setUTCDate(tempAnchor.getUTCDate() + 1);
                    tempCount++;
                }
            } else {
                // MANUAL Mode: Read payments from the manual list
                const manualPaymentElements = document.querySelectorAll('#manualPaymentsList .manual-payment-entry');
                manualPaymentElements.forEach(el => {
                    const startString = el.querySelector('.payment-start').value;
                    const endString = el.querySelector('.payment-end').value;
                    const start = createDate(startString);
                    const end = createDate(endString);
                    
                    if (start && end && end >= start) {
                        originalPayments.push({ 
                            start, 
                            end, 
                            mode: 'Manual'
                        });
                    }
                });
                
                // Sort manual payments and assign 'count' (P1, P2, etc.) based on chronological order
                originalPayments.sort((a, b) => a.start - b.start);
                originalPayments.forEach((p, index) => p.count = index + 1);
                paymentsAlreadyMade = originalPayments.length;
            }

            
            // --- 3. CALCULATE CLAWBACK OFFSET ---
            let unfundedDaysPaidInAdvance = 0;
            let lastPaidPeriodEnd = startDate;
            let nextPaymentCounter = 1;

            if (paymentsAlreadyMade > 0) {
                const paidPeriods = originalPayments; 
                
                paidPeriods.forEach(p => {
                    const periodStart = p.start;
                    const periodEnd = p.end;
                    
                    // Find all UNFUNDED segments that overlap with this paid period
                    const overlappingUnfundedLeaves = processedLeaveEntries.filter(l => 
                        l.fundingType === 'unfunded' && l.start <= periodEnd && l.end >= periodStart
                    );

                    overlappingUnfundedLeaves.forEach(unfundedLeave => {
                        const overlapStart = unfundedLeave.start > periodStart ? unfundedLeave.start : periodStart;
                        const overlapEnd = unfundedLeave.end < periodEnd ? unfundedLeave.end : periodEnd;
                        
                        const overlapDays = dateDiffInDays(overlapStart, overlapEnd);
                        if (overlapDays > 0) {
                            unfundedDaysPaidInAdvance += overlapDays;
                            // Add a note to the LOA entry for rendering later
                            unfundedLeave.notes += ` [NOTE: ${overlapDays} days accidentally covered by Paid P${p.count}. Next payment will be offset by this duration.]`;
                        }
                    });
                });

                // Set lastPaidPeriodEnd and nextPaymentCounter based on the *last* payment in the sorted array
                const lastPayment = originalPayments[originalPayments.length - 1];
                lastPaidPeriodEnd = lastPayment.end;
                nextPaymentCounter = lastPayment.count + 1;
            }

            // --- 4. FINAL EXTENSION AND EFFECTIVE END DATE (Uses full extension) ---
            let finalEffectiveEndDate = new Date(initialFundingEndDate);
            if (initialTotalExtensionDays > 0) {
                finalEffectiveEndDate.setUTCDate(finalEffectiveEndDate.getUTCDate() + initialTotalExtensionDays);
            }
            let gracePeriodDays = unfundedDaysPaidInAdvance;
            
            // --- 5. RENDER HEADER AND CORRECTION NOTE ---
            let htmlContent = `<h3>Funding Summary</h3>`;
            if (fundingDescription) {
                 htmlContent += `<p>Name: <strong>${fundingDescription}</strong></p>`;
            }
            htmlContent += `<p>Initial Funding End Date: <strong>${formatDate(initialFundingEndDate)}</strong></p>`;
            if (initialTotalExtensionDays > 0) {
                 htmlContent += `<p>Total Planned LOA Days (Extension): <strong>${initialTotalExtensionDays} days</strong></p>`;
            }
            
            if (unfundedDaysPaidInAdvance > 0) {
                correctionNote.innerHTML = `‚ö†Ô∏è **CLAWBACK OFFSET APPLIED**: **${unfundedDaysPaidInAdvance}** unfunded LOA days were covered by Payments Already Made (P1 to P${paymentsAlreadyMade}). The next scheduled payment will be **delayed** by this duration.`;
            }
            
            htmlContent += `<p>Effective End Date (Full Extension): <strong>${formatDate(finalEffectiveEndDate)}</strong></p>`;
            
            htmlContent += `<hr><h3>Full Payment Timeline (Chronological)</h3>`;


            // --- 6. ASSEMBLE ALL TIMELINE BLOCKS (Paid, Grace, LOA, Planned) ---
            let timelineBlocks = [];
            
            // 6a. Add MISSED PERIOD (New logic)
            if (modeManual && paymentsAlreadyMade > 0) {
                const firstPaymentStart = originalPayments[0].start;
                // If the first payment starts AFTER the student start date
                if (firstPaymentStart.getTime() > startDate.getTime()) {
                    let missedEnd = new Date(firstPaymentStart);
                    missedEnd.setUTCDate(missedEnd.getUTCDate() - 1);
                    
                    if (missedEnd.getTime() >= startDate.getTime()) {
                         timelineBlocks.push({
                            chronologicalStart: startDate,
                            type: 'MISSED_PERIOD',
                            start: startDate,
                            end: missedEnd,
                            periodInfo: getLeaveDurationInfo(startDate, missedEnd)
                        });
                    }
                }
            }


            // 6b. Add PAID Payments
            originalPayments.forEach(p => {
                timelineBlocks.push({
                    chronologicalStart: p.start, 
                    type: 'PAID_PAYMENT',
                    count: p.count,
                    start: p.start,
                    end: p.end,
                    paymentDate: adjustToPayDate(p.start),
                    // Updated the label text as requested by the user
                    label: `P${p.count} (PAST PAID PERIOD)`, 
                    periodInfo: getLeaveDurationInfo(p.start, p.end)
                });
            });

            // Calculate the start of the NEW schedule anchor: the day after the last paid period
            let newScheduleAnchor = paymentsAlreadyMade > 0 
                ? new Date(lastPaidPeriodEnd) 
                : startDate;
            if (paymentsAlreadyMade > 0) {
                newScheduleAnchor.setUTCDate(newScheduleAnchor.getUTCDate() + 1); 
            }

            let firstPlannedPaymentStart = new Date(newScheduleAnchor);

            // 6c. Add GRACE PERIOD/OFFSET BLOCK (if needed)
            if (gracePeriodDays > 0) {
                let gracePeriodEnd = new Date(newScheduleAnchor);
                gracePeriodEnd.setUTCDate(gracePeriodEnd.getUTCDate() + gracePeriodDays - 1);

                timelineBlocks.push({
                    chronologicalStart: newScheduleAnchor,
                    type: 'GRACE_PERIOD',
                    start: newScheduleAnchor,
                    end: gracePeriodEnd,
                    periodInfo: getLeaveDurationInfo(newScheduleAnchor, gracePeriodEnd),
                    graceDays: gracePeriodDays
                });
                
                firstPlannedPaymentStart = new Date(gracePeriodEnd);
                firstPlannedPaymentStart.setUTCDate(firstPlannedPaymentStart.getUTCDate() + 1); 
            }
                
            // 6d. Add LOA Segments (Only UNFUNDED LOA are added here. Funded/Reduced are covered in payment blocks.)
            processedLeaveEntries.forEach(leave => {
                // Only render separate blocks for unfunded LOAs.
                if (leave.fundingType === 'unfunded') { 
                    // Only add if it falls within the entire funding timeline (original + extension)
                    if (leave.start.getTime() <= finalEffectiveEndDate.getTime() || leave.end.getTime() >= startDate.getTime()) {
                        timelineBlocks.push({
                            chronologicalStart: leave.start,
                            type: 'LOA',
                            start: leave.start,
                            end: leave.end,
                            leave: leave
                        });
                    }
                }
            });

            // 6e. Add PLANNED Payments (Starting from the delayed anchor, applying the new catch-up/reset logic)
            let shiftedPayments = [];
            let currentPaymentCounter = nextPaymentCounter;

            // Anchor for the start of the *planned* schedule, including any clawback delay
            let scheduleAnchor = new Date(firstPlannedPaymentStart); 

            // Calculate the true, unshifted start date for the *next* expected payment (P_next)
            let trueNextScheduledEnd = new Date(startDate);
            // Advance by currentPaymentCounter (e.g., 2) quarterly blocks to find the true end date
            trueNextScheduledEnd.setUTCMonth(trueNextScheduledEnd.getUTCMonth() + currentPaymentCounter * QUARTERLY_MONTHS);
            trueNextScheduledEnd.setUTCDate(trueNextScheduledEnd.getUTCDate() - 1); 
            let trueNextScheduledStart = new Date(trueNextScheduledEnd);
            trueNextScheduledStart.setUTCMonth(trueNextScheduledStart.getUTCMonth() - QUARTERLY_MONTHS);
            trueNextScheduledStart.setUTCDate(trueNextScheduledStart.getUTCDate() + 1);
            
            // --- NEW SCHEDULE RESET LOGIC (Manual Mode Only, No LOA Clawback) ---
            if (modeManual && !gracePeriodDays) { 
                 // If the true start of the next payment (e.g., Jan 1) is before the current schedule anchor (e.g., Feb 1),
                 // we reset the anchor to the true start date to force the "catch-up" overlap as requested by the user.
                 if (trueNextScheduledStart.getTime() < scheduleAnchor.getTime()) {
                      scheduleAnchor = trueNextScheduledStart;
                 }
            }


            // 2. Calculate the remaining payments starting from the (potentially reset) anchor
            if (scheduleAnchor.getTime() <= finalEffectiveEndDate.getTime()) {
                const remainingPayments = calculateShiftedPayments(
                    scheduleAnchor, 
                    finalEffectiveEndDate, 
                    processedLeaveEntries, 
                    currentPaymentCounter
                );
                shiftedPayments.push(...remainingPayments);
            }

            shiftedPayments.forEach(p => {
                let paymentType = p.type;
                let paymentLabel;
                
                if (p.type === 'CATCH_UP_PRORATA') { 
                    paymentType = 'PLANNED_CATCH_UP_PRORATA';
                    paymentLabel = 'CATCH-UP PRO-RATA (Schedule Alignment)';
                } else {
                    paymentType = p.type === 'PRO-RATA' ? 'PLANNED_PRORATA_SHIFT' : 'PLANNED_REGULAR';
                    paymentLabel = p.type === 'PRO-RATA' ? 'PRO-RATA Pre-LOA Shift' : 'REGULAR';
                    
                    let overlappingLeaves = getLeavesInEffect(p.start, p.end, processedLeaveEntries);
                    let currentPeriodCoveredByFundedOrReducedLOA = overlappingLeaves.some(l => (l.fundingType === 'funded' || l.fundingType === 'reduced') && l.start <= p.end && l.end >= p.start);

                    if (currentPeriodCoveredByFundedOrReducedLOA) {
                        paymentType = 'PLANNED_COMBINED';
                        paymentLabel = 'COMBINED PAYMENT';
                    }
                     
                    // --- FIX: Check if it's a *short* final payment ---
                    const daysInQuarter = dateDiffInDays(p.start, p.end);
                    // A full 3-month quarter is 90, 91, or 92 days. We use 89 as the threshold for 'short'.
                    const isShortFinalPayment = p.end.getTime() === finalEffectiveEndDate.getTime() && daysInQuarter < 89; 

                    if (isShortFinalPayment) {
                        paymentType = 'PLANNED_FINAL_PRORATA';
                        paymentLabel = 'FINAL PRO-RATA';
                    } else if (p.end.getTime() === finalEffectiveEndDate.getTime()) {
                         // If it ends on the final date but IS a full payment, override the label to reflect finality
                         // and use the current paymentType (PLANNED_REGULAR or PLANNED_COMBINED)
                         paymentLabel = 'FINAL REGULAR PAYMENT'; 
                    }
                }


                timelineBlocks.push({
                    chronologicalStart: p.start,
                    type: paymentType,
                    count: p.count,
                    start: p.start,
                    end: p.end,
                    paymentDate: adjustToPayDate(new Date(p.start)),
                    label: `P${p.count} (${paymentLabel})`,
                    periodInfo: getLeaveDurationInfo(p.start, p.end),
                    overlappingLeaves: p.overlappingLeaves || [] 
                });
            });


            // 7. SORT ALL BLOCKS CHRONOLOGICALLY
            timelineBlocks.sort((a, b) => {
                if (a.chronologicalStart.getTime() !== b.chronologicalStart.getTime()) {
                    return a.chronologicalStart.getTime() - b.chronologicalStart.getTime();
                }
                // LOA blocks should appear before payments that start on the same day.
                if (a.type === 'LOA' && b.type !== 'LOA') return -1;
                if (a.type !== 'LOA' && b.type === 'LOA') return 1;
                // Payment blocks should follow the correct payment order
                return (a.count || 999) - (b.count || 999); 
            });


            // 8. RENDER ALL BLOCKS (Populates finalHtml)
            let finalHtml = '';
            let lastChronologicalStart = null;
            let currentBlockSet = [];

            timelineBlocks.forEach(block => {
                 // Group blocks that start on the same day (for visual clarity)
                if (lastChronologicalStart && block.chronologicalStart.getTime() !== lastChronologicalStart.getTime()) {
                    currentBlockSet.forEach(b => finalHtml += renderBlock(b));
                    currentBlockSet = [];
                }
                currentBlockSet.push(block);
                lastChronologicalStart = block.chronologicalStart;
            });
            currentBlockSet.forEach(b => finalHtml += renderBlock(b)); // Render final set

            function renderBlock(block) {
                
                if (block.type === 'MISSED_PERIOD') {
                    return `<div class="timeline-marker missed-period-marker">
                                        <h4>**MISSED PAYMENT PERIOD**</h4>
                                        <p>Period: ${formatDate(block.start)} to ${formatDate(block.end)}</p>
                                        <p>Duration: ${block.periodInfo.display}</p>
                                        <p>Status: **UNPAID / MISSED**</p>
                                        <p>Note: This missing month's pay was recovered in the subsequent P2 payment due to the schedule reset.</p>
                                    </div>`;

                } else if (block.type === 'PAID_PAYMENT') {
                    let statusText = '**PAID**';
                    
                    // Logic to detect if this PAID payment overlaps with the *next* PLANNED payment
                    const nextPlannedPayment = timelineBlocks.find(b => b.type.startsWith('PLANNED') && b.count === block.count + 1);
                    if (nextPlannedPayment && nextPlannedPayment.start.getTime() <= block.end.getTime()) {
                         statusText = `**PAID (Overlapped with P${nextPlannedPayment.count} - Schedule Reset)**`;
                    }
                    
                    if (unfundedDaysPaidInAdvance > 0 && block.count <= paymentsAlreadyMade) {
                        const periodStart = block.start;
                        const periodEnd = block.end;
                        const hasOverlap = processedLeaveEntries.some(l => 
                            l.fundingType === 'unfunded' && l.start <= periodEnd && l.end >= periodStart
                        );
                        if(hasOverlap) {
                            statusText = '**PAID (Contributed to clawback offset)**';
                        }
                    }

                    return `<div class="timeline-marker payment-marker-paid">
                                        <h4>${block.label}</h4>
                                        <p>Payment Date: <strong>${formatDate(adjustToPayDate(block.start))}</strong></p>
                                        <p>Period Covered: ${formatDate(block.start)} to ${formatDate(block.end)}</p>
                                        <p>Duration: ${block.periodInfo.display}</p>
                                        <p>Status: ${statusText}</p>
                                    </div>`;

                } else if (block.type === 'GRACE_PERIOD') {
                    return `<div class="timeline-marker grace-period-marker">
                                        <h4>**PAYMENT OFFSET/GRACE PERIOD**</h4>
                                        <p>Period: ${formatDate(block.start)} to ${formatDate(block.end)}</p>
                                        <p>Duration: ${block.periodInfo.display}</p>
                                        <p>Reason: Offset for **${block.graceDays} unfunded days** accidentally paid in advance.</p>
                                        <p>Status: **NO PAYMENT ISSUED**</p>
                                    </div>`;
                                    
                } else if (block.type === 'LOA') {
                    const leave = block.leave;
                    // Only render separate blocks for UNFUNDED LOAs, using the generic unfunded style.
                    let typeClass = 'leave-marker-unfunded'; 
                    let typeLabel = `UNFUNDED LOA (Source: ${leave.originalType.toUpperCase().replace(/-/g, ' ')})`;
                    
                    return `<div class="timeline-marker ${typeClass}">
                                        <h4>${typeLabel}</h4>
                                        <p>Period: ${formatDate(leave.start)} to ${formatDate(leave.end)}</p>
                                        <p>Duration: ${leave.display}</p>
                                        <p>Description: ${leave.description}</p>
                                        <p>Funding Status: <strong>UNFUNDED (Triggers schedule shift)</strong></p>
                                        <p>Notes: ${leave.notes || 'This period is unfunded and causes a stipend payment delay/extension.'}</p>
                                    </div>`;
                                    
                } else if (block.type.startsWith('PLANNED')) {
                    let markerClass = 'payment-marker'; // Default to green
                    let paymentDetails = [];
                    
                    if (block.type === 'PLANNED_FINAL_PRORATA' || block.type === 'PLANNED_PRORATA_SHIFT') {
                         markerClass = 'payment-marker-prorata';
                    } else if (block.type === 'PLANNED_CATCH_UP_PRORATA') {
                        markerClass = 'payment-marker-split';
                    }
                    
                    if (block.type === 'PLANNED_COMBINED') {
                        // Logic to detail combined payment periods
                        const currentPeriodStart = block.start;
                        const finalPeriodEnd = block.end;
                        const paymentPeriodEnd = finalPeriodEnd; 
                        let nextSegmentStart = currentPeriodStart;

                        const fundedOverlaps = block.overlappingLeaves
                            .filter(l => l.fundingType === 'funded' || l.fundingType === 'reduced')
                            .map(l => {
                                let segment = { ...l };
                                segment.start = l.start > currentPeriodStart ? l.start : currentPeriodStart;
                                segment.end = l.end < paymentPeriodEnd ? l.end : paymentPeriodEnd;

                                if (segment.start <= segment.end) return segment;
                                return null;
                            })
                            .filter(Boolean);
                        fundedOverlaps.sort((a, b) => a.start - b.start);
                        
                        let totalLoaDays = fundedOverlaps.reduce((sum, l) => sum + dateDiffInDays(l.start, l.end), 0);
                        const totalPeriodDays = dateDiffInDays(block.start, block.end);
                        let isFullLoaPayment = (totalLoaDays === totalPeriodDays);
                        
                        const containsMatFull = fundedOverlaps.some(l => l.type.startsWith('maternity-full'));
                        const containsMatSmp = fundedOverlaps.some(l => l.type.startsWith('maternity-smp'));

                        // --- START REFINED COLOR & LABEL LOGIC ---
                        
                        // Case 1: Maternity Full + SMP Split (highest priority)
                        if (containsMatFull && containsMatSmp) {
                            markerClass = 'leave-marker-maternity-split';
                            block.label = `P${block.count} (MATERNITY SPLIT PERIOD)`; 
                        } 
                        // Case 2: 100% LOA Payment (Single LOA type)
                        else if (isFullLoaPayment) {
                            let primaryLoaType = fundedOverlaps[0].type;
                            
                            // Determine the class based on the primary (first) funded LOA type
                            if (primaryLoaType.startsWith('maternity-full')) {
                                markerClass = 'leave-marker-maternity-full';
                                block.label = `P${block.count} (MATERNITY FULL FULL PERIOD)`; 
                            } else if (primaryLoaType.startsWith('maternity-smp')) {
                                markerClass = 'leave-marker-maternity-smp';
                                block.label = `P${block.count} (MATERNITY SMP FULL PERIOD)`;
                            } else if (primaryLoaType === 'medical') {
                                markerClass = 'leave-marker-medical';
                                block.label = `P${block.count} (MEDICAL FULL PERIOD)`;
                            } else {
                                 markerClass = 'payment-marker-split'; 
                                 block.label = `P${block.count} (LOA FULL PERIOD)`;
                            }
                            
                        } 
                        // Case 3: Mixed Regular Stipend + LOA (Default split color, use peach for any Maternity mix)
                        else {
                            markerClass = 'payment-marker-split'; // Default light blue
                            block.label = 'COMBINED PAYMENT';
                            
                            if (containsMatFull || containsMatSmp) {
                                // If it's a mix of Regular Stipend + a Maternity type (Full or SMP), use the peach split color
                                markerClass = 'leave-marker-maternity-split';
                            } 
                        }
                        // --- END REFINED COLOR & LABEL LOGIC ---
                        
                        
                        // --- PAYMENT DETAILS GENERATION (UNCHANGED) ---
                        // The logic below correctly generates the segment details for all combined/split types.

                        if (isFullLoaPayment) {
                            let primaryLoaTypeLabel = fundedOverlaps[0].type.toUpperCase().replace(/-/g, ' ');
                            
                            fundedOverlaps.forEach((fundedLeave, index) => {
                                let allowanceLabel;
                                if (fundedLeave.type === 'maternity-full') allowanceLabel = 'MATERNITY Full Stipend Allowance';
                                else if (fundedLeave.type === 'maternity-smp') allowanceLabel = 'MATERNITY REDUCED (SMP) Allowance';
                                else if (fundedLeave.type === 'funded-capped') allowanceLabel = 'FUNDED CAPPED Allowance';
                                else if (fundedLeave.type === 'medical') allowanceLabel = 'MEDICAL Allowance';
                                else allowanceLabel = fundedLeave.type.toUpperCase().replace(/-/g, ' ') + ' Allowance';

                                const segmentStart = fundedLeave.start;
                                const segmentEnd = fundedLeave.end;
                                const duration = dateDiffInDays(segmentStart, segmentEnd);
                                    
                                paymentDetails.push(`<li>${allowanceLabel}: ${formatDate(segmentStart)} to ${formatDate(segmentEnd)} (${duration} days)</li>`);
                                
                                // Show description once for the primary type
                                if (index === 0) {
                                     paymentDetails.push(`<li>LOA Description: <strong>${fundedLeave.description}</strong></li>`);
                                }
                            });
                        } else {
                            // --- ORIGINAL COMBINED LOGIC (True Mix) ---
                            // 1. Process Pre-LOA regular stipend
                            if (fundedOverlaps.length > 0 && fundedOverlaps[0].start > currentPeriodStart) {
                                 const preLoaEnd = new Date(fundedOverlaps[0].start);
                                 preLoaEnd.setUTCDate(preLoaEnd.getUTCDate() - 1);
                                 const preLoaInfo = getLeaveDurationInfo(currentPeriodStart, preLoaEnd);
                                paymentDetails.push(`<li>Regular Stipend: ${formatDate(currentPeriodStart)} to ${formatDate(preLoaEnd)} (${preLoaInfo.display})</li>`);
                                 nextSegmentStart = new Date(fundedOverlaps[0].start);
                            } 
                            
                            // 2. Process all funded/reduced LOA segments
                            for(let i = 0; i < fundedOverlaps.length; i++) {
                                const fundedLeave = fundedOverlaps[i];
                                let allowanceLabel;
                                if (fundedLeave.type === 'maternity-full') allowanceLabel = 'MATERNITY Full Stipend Allowance';
                                else if (fundedLeave.type === 'maternity-smp') allowanceLabel = 'MATERNITY REDUCED (SMP) Allowance';
                                else if (fundedLeave.type === 'funded-capped') allowanceLabel = 'FUNDED CAPPED Allowance';
                                else if (fundedLeave.type === 'medical') allowanceLabel = 'MEDICAL Allowance';
                                else allowanceLabel = fundedLeave.type.toUpperCase().replace(/-/g, ' ') + ' Allowance';

                                const segmentStart = fundedLeave.start;
                                const segmentEnd = fundedLeave.end;
                                const duration = dateDiffInDays(segmentStart, segmentEnd);
                                
                                paymentDetails.push(`<li>${allowanceLabel}: ${formatDate(segmentStart)} to ${formatDate(segmentEnd)} (${duration} days)</li>`);
                                if (i === 0 || fundedOverlaps[i-1].originalType !== fundedLeave.originalType) {
                                    paymentDetails.push(`<li>LOA Description: <strong>${fundedLeave.description}</strong></li>`);
                                }
                                
                                nextSegmentStart = new Date(fundedLeave.end);
                                nextSegmentStart.setUTCDate(nextSegmentStart.getUTCDate() + 1);
                                
                                // Intervening Regular Stipend 
                                if (i < fundedOverlaps.length - 1) {
                                    const nextLoaStart = fundedOverlaps[i+1].start;
                                    const regularEnd = new Date(nextLoaStart);
                                    regularEnd.setUTCDate(regularEnd.getUTCDate() - 1);

                                    if (nextSegmentStart.getTime() <= regularEnd.getTime()) {
                                        const regularInfo = getLeaveDurationInfo(nextSegmentStart, regularEnd);
                                        paymentDetails.push(`<li>Regular Stipend: ${formatDate(nextSegmentStart)} to ${formatDate(regularEnd)} (${regularInfo.display})</li>`);
                                        nextSegmentStart = new Date(regularEnd);
                                        nextSegmentStart.setUTCDate(nextSegmentStart.getUTCDate() + 1);
                                    }
                                }
                            }

                            // 3. Process Post-LOA regular stipend
                            if (nextSegmentStart.getTime() <= finalPeriodEnd.getTime()) {
                                const postLoaInfo = getLeaveDurationInfo(nextSegmentStart, finalPeriodEnd);
                                paymentDetails.push(`<li>Regular Stipend: ${formatDate(nextSegmentStart)} to ${formatDate(finalPeriodEnd)} (${postLoaInfo.display})</li>`);
                            }
                            // --- END ORIGINAL COMBINED LOGIC ---
                        }

                    }
                    
                    return `<div class="timeline-marker ${markerClass}">
                                        <h4>${block.label}</h4>
                                        <p>Payment Date: <strong>${formatDate(block.paymentDate)}</strong></p>
                                        <p>Period Covered: ${formatDate(block.start)} to ${formatDate(block.end)}</p>
                                        <p>Duration: ${block.periodInfo.display}</p>
                                        ${paymentDetails.length > 0 ? `<ul>${paymentDetails.join('')}</ul>` : ''}
                                        <p>Status: **PLANNED**</p>
                                    </div>`;
                }
                return ''; // Should not happen
            }

            // Write the header content AND the generated timeline blocks (finalHtml)
            timelineContainer.innerHTML = htmlContent + finalHtml;
        }
        
        // --- PDF GENERATOR FUNCTION ---
        async function downloadPDF() {
            // Check if jsPDF and html2canvas are loaded before proceeding
            if (typeof html2canvas === 'undefined' || typeof jsPDF === 'undefined') {
                alert("PDF download failed: Required libraries did not load. Please ensure you are online.");
                console.error("html2canvas loaded:", typeof html2canvas !== 'undefined', "jsPDF loaded:", typeof jsPDF !== 'undefined');
                return;
            }

            const element = document.getElementById('timeline-results-section'); // Target the whole results section

            const canvas = await html2canvas(element, {
                scale: 2, 
                useCORS: true, 
                scrollY: 0, 
            });

            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF('p', 'mm', 'a4'); 
            
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            const imgHeight = (canvas.height * pdfWidth) / canvas.width;
            
            let heightLeft = imgHeight;
            let position = 0;

            pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
            heightLeft -= pdfHeight;

            while (heightLeft > 0) {
                position = heightLeft - imgHeight; 
                pdf.addPage();
                pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                heightLeft -= pdfHeight;
            }

            pdf.save("Student_Stipend_Timeline.pdf");
        }
        
        // --- UI TOGGLE AND INITIALIZATION ---
        function togglePaymentMode() {
            const modeAuto = document.getElementById('modeAuto').checked;
            document.getElementById('autoControls').style.display = modeAuto ? 'block' : 'none';
            document.getElementById('manualPaymentDetails').style.display = modeAuto ? 'none' : 'block';
            
            // Clear Manual entries if switching to Auto mode (optional but helpful)
            if (modeAuto) {
                 document.getElementById('manualPaymentsList').innerHTML = '';
            }
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            const generateBtn = document.getElementById('generateTimelineBtn');
            const addLeaveBtn = document.getElementById('addLeaveBtn');
            const downloadPdfBtn = document.getElementById('downloadPdfBtn');
            const addManualPaymentBtn = document.getElementById('addManualPaymentBtn');
            const radioButtons = document.querySelectorAll('input[name="paymentMode"]');
            

            if (generateBtn) {
                generateBtn.addEventListener('click', generateTimeline);
            }
            
            if (addLeaveBtn) {
                addLeaveBtn.addEventListener('click', addLeavePeriod);
            }
            
            if (downloadPdfBtn) {
                downloadPdfBtn.addEventListener('click', downloadPDF);
            }
            
            if (addManualPaymentBtn) {
                addManualPaymentBtn.addEventListener('click', addManualPayment);
            }
            
            radioButtons.forEach(radio => radio.addEventListener('change', togglePaymentMode));

            // --- USER SCENARIO SETUP (Reset to empty/manual) ---
            document.getElementById('modeAuto').checked = false; // Ensure auto is unchecked
            document.getElementById('modeManual').checked = true; // Ensure manual is checked
            document.getElementById('paymentsAlreadyMade').value = '0';
            togglePaymentMode();
            
            // Remove the default LOA entry to ensure a completely clean start for the user
            const defaultLeaveEntry = document.querySelector('#leavePeriods .leave-entry');
            if(defaultLeaveEntry) {
                 defaultLeaveEntry.remove();
            }


            // Do NOT call generateTimeline() on load so the user sees the initial "Press 'Generate Timeline'..." message.
            // generateTimeline(); 
        });
    </script>

</body>
</html>
